* halValidate needs to have initSize, it is a bit tricky for halExport, you can't reallya pass the parser in because it only allows one "format", so I hacked it up.
* Add a units suffix (G, M) to mmapInitSize
* Drop mmap grow functionality, as it doesn't seem to work.  Maybe estimate the initial size from the input or just make it huge.
* api/impl/defaultMappedSegment.h says
note it would be nice to extend SegmentIterator but the crappy smart pointer interface makes it impossible to use "this" as a parameter to lots of api functions.  simplest for now just to contain a pair of segment iterators and wrap up all the interface methods. 
* Get rid of iterators implementing the types they are iterating over.  Add an explict get or operator*. This will allow  more inlining.
* does this still make sense now that databases doesn't have constness defaultGappedBottomSegmentIterator.h - keep convention of other iterators where const-ness only applies to the database and not the iterator...
* getSegment is duplicated in different places due to top/bottom/gapped/ungapped implementations.  Is this a good approach?
* typedef containers for HAL objects (e.g. std::set<MappedSegmentPtr>) instead of repeating
* make more members private
* change to std::shared_ptr
* there should not be const pointers for iterators??  Check why const_pointer_cast is needed
* how useful is it that Top/BottomSegmentIterators are the same base class?  Do you ever just iterate not caring? joel: hmm, not sure. i feel like you almost always *should* care, but IIRC the mappedSegment code uses the generic SegmentIterator and downcasts it based on the isTop() response when it needs to treat it like a top/bottom segment.  This creates dynamic casts, but because SegmentIterator is virtual.
* Investigate const casts added with std::shared_ptr, are they really needed?
* Why Genome* rather than smart pointer: halMappedSegmentTest.cpp
* change most pointer function arguments to be reference.
* behavior of ColumnIterator: the last column is inclusive, so if you use toRight() on the last base you crash
* DNAIterator doesn't have a direct way to check for end
  hal_index_t n = ancGenome->getSequenceLength();
  DNAIteratorPtr dnaIt = ancGenome->getDNAIterator();
  for (; dnaIt->getArrayIndex() < n; dnaIt->toRight()) {
* smart pointer casting:
https://herbsutter.com/2012/06/21/reader-qa-why-dont-modern-smart-pointers-implicitly-convert-to/
* dropped gapped??: "Interface for Gapped Top Segment iterator.  Only used internally"
- used by halChain (which doesn't do anything) and halSummarizeMutations (which doesn't work right)
* hdf5DNAIterator structure could be collapsed with generic if genome provide a way to get an array
of DNA.  Maybe pack DNA in mmap?
* Using stTree with C-strings results in copying rather than sharing strings.
* C interface to blockViz is weird, with optional thowing an exception or returning a C string.
* api/mmap_impl/mmapGenome.h:
    We request twice the segment length here because checking the length of
    this segment requires reading the start position of the following segment.
* lastColumn()  should be atEnd
* Segment interface:
- Why setArrayIndex vs creating new segment object?  This seems to so object can
  be reused by iterator, it doesn't really represent a segment, can't cache.   So seems more like a function bag.
- Function setArrayIndex is a bad name.
- can't cache
- segment is region of sequence with start and length -- determined by how much gapless alignment there is to its parent/children
* Things that probably don't work very well:
- hal::Rearrangement
- inc/halChain.h
- hal::GappedBottomSegmentIterator
* Document why SlicedSegment vs Segment
* writing a custom MappedSegmentSet that hits smart pointer would be really nice
* Change confusing is-a relationships to has-a:
** MappedSegement could have reference to source and target, not be source and get target
* six almost identical implementations of Segment.isMissingData
  HDF5BottomSegment::isMissingData  hdf5s idential
  HDF5TopSegment::isMissingData
  GappedBottomSegmentIterator::isMissingData gapped identical
  GappedTopSegmentIterator::isMissingData
  MMapBottomSegment::isMissingData  mmaps idential
  MMapTopSegment::isMissingData
- only difference is drive ones have specific implemented of DNAIterator, which could
  be inlined.  However, if DNAIterator is generic, this goes away
